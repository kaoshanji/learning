# 高水平的分布式系统

> 分布式编程是解决使用多台计算机在单台计算机上解决的相同问题的技巧。

任何计算机系统都需要完成两个基本任务：

- 存储
- 计算

分布式编程是解决使用多台计算机在单台计算机上解决的相同问题的艺术 - 通常，因为问题不再适用于单台计算机。

没有什么真正要求您使用分布式系统。鉴于无限的资金和无限的研发时间，我们不需要分布式系统。所有的计算和存储都可以在一个神奇的盒子上完成 - 一个单一的，令人难以置信的快速和令人难以置信的可靠系统*，你付钱给别人为你设计*。

但是，很少有人拥有无限的资源。因此，他们必须在一些现实世界的成本效益曲线上找到合适的位置。在小范围内，升级硬件是一种可行的策略。但是，随着问题规模的增加，您将达到允许您在单个节点上解决问题的硬件升级不存在或成本过高的程度。那时，我欢迎您来到分布式系统的世界。

目前的现实是，最好的价值在于中档商用硬件 - 只要通过容错软件可以降低维护成本。

计算主要受益于高端硬件，它们可以用内部存储器访问来代替慢速网络访问。高端硬件的性能优势在需要节点之间需要大量通信的任务中受到限制。

![成本效益](images/barroso_holzle.png)

正如上图来自[Barroso，Clidaras和Hölzle](http://www.morganclaypool.com/doi/abs/10.2200/S00516ED2V01Y201306CAC024)所示，高端和商用硬件之间的性能差距随着簇大小而减小，假设所有节点都有统一的内存访问模式。

理想情况下，添加新机器将线性地提高系统的性能和容量。但当然这是不可能的，因为由于具有单独的计算机而产生一些开销。需要复制数据，必须协调计算任务等。这就是研究分布式算法的原因 - 它们为特定问题提供了有效的解决方案，并提供了可行的指导，正确实施的最低成本是什么，以及什么是不可能的。

本文的重点是分布式编程和系统，这是一个平凡但商业上相关的设置：数据中心。例如，我不会讨论因异常网络配置或共享内存设置中出现的特殊问题。此外，重点是探索系统设计空间而不是优化任何特定设计 - 后者是更专业化文本的主题。

## 我们想要实现的目标：可扩展性和其他好东西

我看待它的方式，一切都从处理大小的需要开始。

大多数事情都是微不足道的 - 一旦你超过一定的规模，数量或其他身体上有限的东西，同样的问题会变得更加困难。提起一块巧克力很容易，很难举起一座山。很容易计算一个房间里有多少人，很难计算一个国家有多少人。

所以一切都从尺寸开始 - 可扩展性。非正式地说，在我们从小到大的可扩展系统中，事情不应该越来越糟。这是另一个定义：

- [可扩展性](http://en.wikipedia.org/wiki/Scalability)

  系统，网络或流程能够以有能力的方式处理越来越多的工作，或者能够扩大以适应这种增长。

什么是增长？那么，您几乎可以用任何方式衡量增长（人数，用电量等）。但是有三个特别有趣的事情要看：

- 大小可扩展性：添加更多节点应该使系统线性更快; 增长数据集不应该增加延迟
- 地理可扩展性：应该可以使用多个数据中心来减少响应用户查询所需的时间，同时以一种合理的方式处理跨数据中心延迟。
- 管理可扩展性：添加更多节点不应增加系统的管理成本（例如管理员与机器的比率）。

当然，在实际系统中，同时在多个不同的轴上发生增长; 每个指标都只捕获了增长的某些方面。

可扩展系统是随着规模的增加而不断满足其用户需求的系统。有两个特别相关的方面 - 性能和可用性 - 可以通过各种方式进行衡量。

### 性能（和延迟）

- [性能](http://en.wikipedia.org/wiki/Computer_performance)

  其特征在于计算机系统与所用时间和资源相比完成的有用工作量。

根据具体情况，这可能涉及实现以下一项或多项：

- 对于给定的工作，响应时间短/低延迟
- 高吞吐量（加工工作率）
- 计算资源利用率低

在优化任何这些结果时都需要权衡。例如，系统可以通过处理更大批量的工作来实现更高的吞吐量，从而减少操作开销。由于批处理，权衡对于各个工作的响应时间会更长。

我发现低延迟 - 实现较短的响应时间 - 是性能中最有趣的方面，因为它与物理（而非财务）限制有很强的联系。使用财务资源解决延迟比处理性能的其他方面更难。

延迟有很多非常具体的定义，但我真的喜欢这个词的词源唤起的想法：

- 潜伏

  潜伏的状态; 延迟，是事物发生与事件发生之间的一段时间。

什么是“潜伏”是什么意思？

- 潜

  来自拉丁语latens，latentis，lateo的现在分词（“lie hidden”）。现有或现在但隐藏或不活跃。

这个定义非常酷，因为它突出了延迟实际上是事件发生的时间和影响或变得可见的时间。

例如，假设您感染了一种将人变成僵尸的空气传播病毒。潜伏期是从你被感染到变成僵尸之间的时间。这是延迟：从已经发生的事情被隐藏的时间。

让我们暂时假设我们的分布式系统只执行一个高级任务：给定查询，它获取系统中的所有数据并计算单个结果。换句话说，将分布式系统视为一个数据存储，能够在其当前内容上运行单个确定性计算（函数）：

```
result = query(all data in the system)
```

然后，对于延迟而言重要的不是旧数据的数量，而是新数据在系统中“生效”的速度。例如，延迟可以根据读取对读者可见的时间来衡量。

基于这个定义的另一个关键点是，如果没有任何反应，就没有“潜伏期”。数据不变的系统不会（或不应该）具有延迟问题。

在分布式系统中，存在无法克服的最小延迟：光速限制了信息传输的速度，硬件组件每次操作产生的延迟成本最低（想想RAM和硬盘驱动器以及CPU）。

最小延迟对查询的影响程度取决于这些查询的性质以及信息需要传输的物理距离。

### 可用性（和容错）

可扩展系统的第二个方面是可用性。

- [可用性](http://en.wikipedia.org/wiki/High_availability)

  系统处于运行状态的时间比例。如果用户无法访问系统，则称其不可用。

分布式系统使我们能够实现在单个系统上难以实现的理想特性。例如，单个机器无法容忍任何故障，因为它要么失败要么失败。

分布式系统可以采用一堆不可靠的组件，并在它们之上构建可靠的系统。

没有冗余的系统只能作为其底层组件可用。使用冗余构建的系统可以容忍部分故障，因此更容易获得。值得注意的是，“冗余”可能意味着不同的东西，具体取决于您所看到的内容 - 组件，服务器，数据中心等。

在公式上，可用性是：`Availability = uptime / (uptime + downtime)`。

从技术角度来看，可用性主要是关于容错。因为发生故障的概率随着组件的数量而增加，所以系统应该能够进行补偿，以便随着组件数量的增加而变得不那么可靠。

例如：

| 可用性 ％             | 每年允许多少停机时间？ |
| --------------------- | ---------------------- |
| 90％（“一九”）        | 一个多月了             |
| 99％（“两个九”）      | 不到4天                |
| 99.9％（“三个九”）    | 不到9个小时            |
| 99.99％（“四个九”）   | 不到一个小时           |
| 99.999％（“五个九”）  | ~5分钟                 |
| 99.9999％（“六个九”） | ~31秒                  |

从某种意义上说，可用性是一个比正常运行时间更宽泛的概念，因为服务的可用性也会受到网络中断或拥有服务的公司的影响（这可能是一个与实际无关的因素）容错但仍会影响系统的可用性）。但是，如果不了解系统的每个特定方面，我们所能做的最好的是容错设计。

容错是什么意思？

- 容错

  一旦发生故障，系统就能以明确定义的方式运行

容错归结为：定义您期望的故障，然后设计一个容忍它们的系统或算法。你不能容忍你没有考虑过的错误。

## 什么阻止我们取得好成绩？

分布式系统受两个物理因素的限制：

- 节点数量（随着所需的存储和计算能力而增加）
- 节点之间的距离（信息传播，充其量，以光速）

在这些约束下工作：

- 独立节点数量的增加会增加系统故障的可能性（降低可用性并增加管理成本）
- 独立节点数量的增加可能会增加节点之间通信的需求（随着规模的增加而降低性能）
- 地理距离的增加会增加远程节点之间通信的最小延迟（降低某些操作的性能）

超出这些趋势 - 这是物理限制的结果 - 是系统设计选择的世界。

性能和可用性都由系统的外部保证定义。在较高的层面上，您可以将保证视为系统的SLA（服务级别协议）：如果我写数据，我可以多快在其他地方访问它？写完数据后，我有什么保证耐用性？如果我要求系统运行计算，它返回结果的速度有多快？当组件发生故障或停止运行时，这会对系统产生什么影响？

还有另一个标准，没有明确提及但暗示：可懂度。保证是多么可以理解？当然，没有简单的指标可以理解。

我有点想在物理限制下加入“可理解性”。毕竟，在人们的硬件限制中，我们很难理解任何涉及[比我们手指更多动人的东西](http://en.wikipedia.org/wiki/Working_memory#Capacity)。这是错误和异常之间的区别 - 错误是不正确的行为，而异常是意外行为。如果你更聪明，你会发现异常发生。

## 抽象和模型

这就是抽象和模型发挥作用的地方。通过消除与解决问题无关的现实世界方面，抽象使事情更易于管理。模型以精确的方式描述分布式系统的关键属性。我将在下一章讨论多种模型，例如：

- 系统模型（异步/同步）
- 故障模型（崩溃 - 失败，分区，拜占庭）
- 一致性模型（强大，最终）

良好的抽象使得使用系统更容易理解，同时捕获与特定目的相关的因素。

在存在许多节点的现实与我们对“像单一系统一样工作”的系统的需求之间存在着紧张关系。通常，最熟悉的模型（例如，在分布式系统上实现共享内存抽象）太昂贵了。

制定较弱保证的制度具有更大的行动自由，因此可能具有更高的绩效 - 但也可能难以推理。人们更擅长推理像单个系统一样工作的系统，而不是节点集合。

人们通常可以通过暴露有关系统内部的更多细节来获得性能。例如，在[列式存储中](http://en.wikipedia.org/wiki/Column-oriented_DBMS)，用户可以（在某种程度上）推断系统内键值对的位置，从而做出影响典型查询性能的决策。隐藏这些细节的系统更容易理解（因为它们更像是单个单元，需要考虑更少的细节），而暴露更多真实细节的系统可能更具性能（因为它们更接近现实） 。

几种类型的故障使得编写像单个系统一样的分布式系统变得困难。网络延迟和网络分区（例如某些节点之间的总网络故障）意味着系统有时需要做出艰难的选择，以确定是否更好地保持可用但丢失一些无法实施的关键保证，或者保证安全并拒绝客户端当发生这些类型的故障时。

CAP定理 - 我将在下一章讨论 - 捕捉到一些紧张局势。最后，理想的系统满足程序员的需求（干净的语义）和业务需求（可用性/一致性/延迟）。

## 设计技巧：分区和复制

数据集在多个节点之间分配的方式非常重要。为了使任何计算发生，我们需要定位数据然后对其进行操作。

有两种基本技术可以应用于数据集。它可以分割为多个节点（分区）以允许更多并行处理。它还可以复制或缓存在不同的节点上，以减少客户端和服务器之间的距离，并提高容错能力（复制）。

> 划分和征服 - 我的意思是，分区和复制。

下图说明了这两者之间的区别：分区数据（下面的A和B）被分成独立的集合，而复制的数据（下面的C）被复制到多个位置。

![分区和复制](images/part-repl.png)

这是解决分布式计算发挥作用的任何问题的第二步。当然，诀窍在于为您的具体实施选择正确的技术; 有许多算法实现复制和分区，每个算法都有不同的限制和优点，需要根据您的设计目标进行评估。

### 分区

分区将数据集划分为更小的不同独立集合; 这用于减少数据集增长的影响，因为每个分区都是数据的子集。

- 分区通过限制要检查的数据量并通过在同一分区中查找相关数据来提高性能
- 分区通过允许分区独立失败来提高可用性，增加在牺牲可用性之前需要失败的节点数

分区也是特定于应用程序的，因此在不知道具体细节的情况下很难说清楚。这就是为什么重点放在大多数文本中的复制，包括这个。

分区主要是根据您认为的主要访问模式来定义分区，以及处理独立分区带来的限制（例如跨分区的低效访问，不同的增长率等）。

### 复制

复制正在多台机器上复制相同的数据; 这允许更多服务器参与计算。

让我不准确引用[Homer J. Simpson](http://en.wikipedia.org/wiki/Homer_vs._the_Eighteenth_Amendment)：

> 要复制！所有生活问题的原因和解决方案。

复制 - 复制或复制某些东西 - 是我们抵御延迟的主要方式。

- 复制通过使额外的计算能力和带宽适用于新的数据副本来提高性能
- 复制通过创建数据的其他副本来提高可用性，从而增加了在牺牲可用性之前需要失败的节点数

复制是关于提供额外的带宽，以及缓存重要的位置。它还涉及根据某种一致性模型以某种方式保持一致性。

复制允许我们实现可伸缩性，性能和容错。害怕失去可用性或降低性能？复制数据以避免出现瓶颈或单点故障。计算速度慢？在多个系统上复制计算。慢I / O？将数据复制到本地缓存以减少延迟或将数据复制到多台计算机上以提高吞吐量。

复制也是许多问题的根源，因为现在存在必须在多台机器上保持同步的数据的独立副本 - 这意味着确保复制遵循一致性模型。

一致性模型的选择至关重要：良好的一致性模型为程序员提供了干净的语义（换句话说，它保证的属性易于推理）并满足业务/设计目标，如高可用性或强一致性。

只有一个用于复制的一致性模型 - 强一致性 - 允许您编程 - 如果未复制基础数据。其他一致性模型将复制的一些内部暴露给程序员。但是，较弱的一致性模型可以提供较低的延迟和较高的可用性 - 并且不一定难以理解，只是不同。

------

## 进一步阅读

- [数据中心作为计算机 - 仓库规模机器设计简介](http://www.morganclaypool.com/doi/pdf/10.2200/s00193ed1v01y200905cac006) - Barroso＆Hölzle，2008
- [分布式计算的谬误](http://en.wikipedia.org/wiki/Fallacies_of_Distributed_Computing)
- [关于年轻血液分布式系统的注释](http://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/) - 霍奇斯，2013年
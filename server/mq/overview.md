# 概述

##  什么是消息队列？

消息队列，是分布式系统中重要的组件

- 主要解决应用耦合，异步消息，流量削锋等问题
- 可实现高性能，高可用，可伸缩和最终一致性架构，是大型分布式系统不可缺少的中间件


目前主流的消息队列有

- Kafka
- RabbitMQ
- RocketMQ

##  消息队列由哪些角色组成？

生产者(Producer) --> 消息代理(Message Broker) --> 消费者(Consumer)

- 生产者：产生消息
- 消费者：消费消息
- 消息代理：存储消息和转发消息，转发消息分为推送和拉取两种
  - 拉取(pull)：消费者 主动从 消息代理 获取消息
  - 推送(push)：消息代理 主动将消费者感兴趣的消息推送给 消费者

##  应用场景

- 应用解耦
- 异步处理
- 流量削峰
- 日志处理

`应用解耦`

系统间耦合性很强，系统A在代码里直接调用B、C代码，如果要加入D，就需要改代码。

A、B或C改了代码，也需要跟着改改

### 引入消息队列

由 消息队列 作为中介，A系统面对 消息队列，B、C 也面对消息队列，后续有D自己加入，没有其他影响

A和B、C不再直接关联，中间隔着消息队列

举个实际场景的例子，用户支付订单完成后，系统需要给用户发红包、增加积分等等行为，就可以通过这样的方式进行解耦。


`异步处理`

还是 A 调用 B、C、D，这是一种串行、堵塞，一个一个的调用反馈再执行下一步，响应时间是累加的

### 引入消息队列

A 发送三条消息，分别给 B、C和D，就变成了异步、并行执行了，响应时间取决于最慢的那个

使用消息队列进行异步处理，会有一个前提，返回的结果不依赖于处理的结果


`流量消峰`

数据库特别是关系型数据库并不擅长处理高并发访问，如果是直接面对高峰请求，数据库就扛不住了

### 引入消息队列

将请求转发到消息队列中，按照数据库能处理的并发量，从消息队列中逐步拉取消息进行消费，相当于在数据库前面加入缓冲

消息队列的性能会比数据库性能更好，并且，横向的扩展能力更强


`日志处理`

日志处理，是指将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输的问题，简单说就是集中各个系统日志。

嗯，平台系统大了复杂了，分析问题需要数据支撑

- ELK + Kafka 日志方案
  - Kafka ：接收用户日志的消息队列
  - Logstash ：对接 Kafka 写入的日志，做日志解析，统一成 JSON 输出给 Elasticsearch 中
  - Elasticsearch ：实时日志分析服务的核心技术，一个 schemaless ，实时的数据存储服务，通过 index 组织数据，兼具强大的搜索和统计功能。
  - Kibana ：基于 Elasticsearch 的数据可视化组件，超强的数据可视化能力是众多公司选择 ELK stack 的重要原因

##  优缺点

优点就是使用场景了，具体就是能做什么

- 缺点
  - 系统可用性降低：系统引入的外部依赖越多，越容易挂掉，MQ 一挂，整套系统崩溃，所以，消息队列一定要做好高可用
  - 系统复杂度提高：1）消息怎么不重复消息。2）消息怎么保证不丢失。3）需要消息顺序的业务场景，怎么处理
  - 一致性问题：要是 B、C。D 三个系统那里，B、D 两个系统写库成功了，结果 C 系统写库失败了，使用 MQ 时，一定要达到数据的最终一致性


##  消费语义

一共有 3 种，分别如下：

- 消息至多被消费一次：消息可能会丢失，但绝不重传
- 消息至少被消费一次：消息可以重传，但绝不丢失
- 消息仅被消费一次：每一条消息只被传递一次

##  投递方式

- push
  - 优点：及时性
  - 缺点：受限于消费者的消费能力，可能造成消息的堆积
- pull
  - 优点：主动权掌握在消费方，根据自己的消费速度进行拉取
  - 缺点：有消息延迟，不能获得最新的消息




##  待解决问题
- 消费消息的幂等性(业务层自己实现)
- 发送消息的可靠性(根据具体产品)
- 消息的顺序性(根据具体产品)
- 消息积压
- 消息过期
- 实现高可用(根据具体产品)




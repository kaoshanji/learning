#   Netty

Netty 是一个使用Java实现的高性能网络应用框架，应用非常普遍，目前基本上是网络程序的标配。

##  背景

-   现在互联网场景

需要服务器能够支撑十万甚至百万连接，创建对应数量的线程是不现实。

连接多，但是每个连接上的请求并不频繁，线程大部分时间都在等待 I/O 就绪。

-   I/O、并发模型

对于网络请求一般可以分为两个处理阶段，一是接收请求任务，二是处理网络请求

I/O 模型决定连接请求接收发送，并发模型决定数据处理过程

----

##  主要问题

Java 网络编程应用框架，线程模型直接影响网络程序的性能。

BIO 适合连接不是很多的场景，模式是一个连接对应一个线程，上限很低，并且读写操作都是阻塞的

-   网络编程性能的瓶颈

BIO 不足以满足高并发场景下的I/O模型。



----

##  解决方案

-   线程模型

用一个线程来处理多个连接，线程利用率提高，所需的线程数量降低，这就是NIO。

具体实现是 Reactor 模式。

-   socket 处理网络机制

socket 处理 TCP 网络连接请求，是在一个独立的 socket 中，每当有一个 TCP 连接成功建立，都会创建一个新的 socket，之后对 TCP 连接的读写都是由新创建处理的 socket 完成。

处理 TCP 连接请求和读写请求是通过两个不同的 socket 完成的。

----


##  设计实现

-   要素

Netty 中最核心的概念是`事件循环`(EventLoop)，Reactor 模式中的 Reactor，负责监听网络事件并调用事件处理器进行处理。

在 4.x 版本的 Netty 中，网络连接 和 EventLoop 是稳定的多对一关系，而 EventLoop 和 Java线程 是 1 对 1 关系，稳定值得是关系一旦确定就不再发生变化。

一个网络连接只会对应唯一的一个 EventLoop，而一个 EventLoop 也只会对应到一个 Java 线程，所以，一个网络连接只会对应到一个 Java线程，这样对于一个网络连接的事件处理是单线程，就避免了各种并发问题。

由多个 EventLoop 组成了 EventLoopGroup ，实际应用中，一般会创建两个 EventLoopGroup，一个是 bossGroup ，一个称为 workerGroup ，这个与 socket 处理网络机制有关。

bossGroup 用来处理连接请求， workerGroup 用来处理读写请求。

bossGroup 处理完连接请求后，会将这个连接提交给 workerGroup 来处理， workerGroup 里面有多个 EventLoop ，使用负载均衡算法决定由那个 EventLoop 处理。

----


##  应用模式


----

##  典型案例
-   [grpc](https://grpc.io/)
-   [Dubbo](http://dubbo.apache.org/zh-cn/index.html)

----

对于网络请求一般可以分为两个处理阶段，一是接收请求任务，二是处理网络请求

I/O 模型决定连接请求接收发送，并发模型决定数据处理过程

并发系统可以采用多种并发编程模型来实现，并发模型指定了系统中的线程如何通过协作来完成分配给它们的作业。

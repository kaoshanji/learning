#   解决方案

并发系统可以采用多种并发编程模型来实现，并发模型指定了系统中的线程如何通过协作来完成分配给它们的作业。

Java 解决并发问题是原生支持多线程模型，基于共享内存实现通信，线程由操作系统调度使用CPU。

Java 借助第三方类库可以实现其他并发模型，如，借助 [Akka库](https://akka.io/) 实现 actor模型，借助 [Multiverse库](https://github.com/pveentjer/Multiverse) 实现STM模型。

线程是操作系统执行最小单元，由操作系统创建和驱动调用以及切换，操作系统的角度下是在内核态调用，栈空间差不多有1M左右，属于重量级对象。

##  多线程模型

-   Java 并发相关JCP
    -   [Java内存模型](https://jcp.org/en/jsr/detail?id=133)
    -   [并发实用程序](https://jcp.org/en/jsr/detail?id=166)
-   主要解决三个问题
    -   分工：如何高效地拆解任务并分配给线程
    -   同步：线程之间如何协作
    -   互斥：保证同一时刻只允许一个线程访问共享资源
-   通信方式
    -   共享内存

并发多线程编程的基本关注点：多个线程共享可变变量，Java SDK  相关接口类大多数就是为了解决这个问题，并提供更方便的编程工具，特别是针对典型场景模式。

可变变量意味着变量具有`多种状态`。

### 解决多个线程共享可变变量的偏方

解决这个问题，有 4 个偏方。

-   变量不变

如果共享的变量，是写死的，没有更改的入口，那么，无论多少线程以什么顺序访问，得到的值都是一样的，这个问题就没有了，也就是线程安全的，效率很高。

但是，好像，范围只能在特定场景之下。

-   单线程

如果程序是单线程的，也就不存在共享，效率很高的，比如 Redis。

如果一个任务类似网络请求连接，具有单独完整的周期，绑定放在一个线程处理，期间不会被其他线程干扰，那么也不存在共享，这时优化线程模型，也可以发挥多线程的优势，例如 Netty。

-   无状态

因为共享变量具有不同状态，然后，状态的变化不可预知，如果，变量是无状态的，多个线程访问都是相同的，也解决了这个问题，例如：HTTP协议就是无状态，Spring 里的 Bean 默认也是无状态的。

无状态带来一个好处，就是程序扩展比较方便，不需要同步多个节点之间的状态，对于高并发问题看起来很有用啊。

-   异步转同步(有点不算)

因为多个线程访问共享变量顺序不可预测，所以如果可以预测了。

多个线程各自完成自己的任务，这是一个异步的，但是，整体协调流程搞个同步的，对于最终结果也是可以有保证的，看起来也没有因为多个线程共享可变变量的问题了。

### 正面面对多个线程共享可变变量

Java 并发多线程解决这个问题的基本技术：管程

因为是通过共享内存通信，就提供了内存模型，他是承包方，Java 技术的创新。



----


##  管程技术



##  Java内存模型


了解了解决方案，就需要落实到代码层面，终究是要写代码完成逻辑。

----
#   API 变更

Java 多线程 API 变更简述。

##  1.5 之前

Java 在一开始就支持多线程，主要接口、类、关键字 如下：

-   java.lang.Thread类：执行程序中的一个线程，实现 Runnable 接口
-   java.lang.Runnable接口：为线程活动状态下执行代码的对象提供通用协议
-   java.lang.ThreadGroup类：代表一组线程
-   java.lang.ThreadLocal类：提供线程局部变量，每个线程都有仅属于自己的，独立初始化的变量副本
-   java.util.Vector类：同步版集合列表
-   synchronized 关键字：实现临界区，保证这部分代码只会被一个线程访问
-   volatile 关键字：实现禁用缓存，针对单个变量，在 1.5 之前存在争议
-   final 关键字：实现变量不变，针对单个变量，在 1.5 之前优化过度

上面的API可以实现简单少量任务的多线程程序，复杂大量任务的程序会出现问题，并导致性能下降。

-   Thread类

创建Java对象很简单，就是在JVM堆里分配一块内存，但是创建Thread类对象就并不简单，他是操作系统创建，发生了调用系统接口，并且占用空间大概 1M，属于重量级对象。

任务和线程是一对一的关系，有一万个任务就有一万个线程了？那得多少内存了，早就挂了。

改进方法：控制线程数量，让线程可以重用，把线程和任务解耦。

一个任务队列接收任务，就属于JVM堆里一个数据结构了，设置队列有界属性，任务太多使用什么策略处理。

一个线程池管理线程，池里有多个线程，数量可控。线程取出任务队列里的任务执行完之后，不回收继续获取任务，这样就达到重复使用线程的目的。

这个在 1.5 更新里由 java.util.concurrent.Executor(执行器) 相关接口解决。

-   synchronized 关键字

为了实现一段代码同一时间只能被一个线程执行，创建出了临界区达到线程之间互斥，由 synchronized 实现。

synchronized 使用比较简单，当做一个修饰词，修饰的代码可能是整个方法，粗粒度，不够灵活，只想互斥方法里的部分代码不能实现。

线程T1进入临界区，线程T2不能进入阻塞在外面，线程阻塞意味着线程没有干活，效率下降，多个线程都阻塞又会有竞争问题，没有进入的线程继续阻塞。

这个在 1.5 更新里由 java.util.concurrent.locks 包解决，主要实现是锁，各种锁。

-   Vector类

Vector类 属于集合框架，是多线程版集合列表，大量使用 synchronized 关键字，效率较低。

这个在 1.5 更新里由 java.util.concurrent 包下阻塞和并发版集合解决，效率较高。








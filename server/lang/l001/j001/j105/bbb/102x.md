#   主要问题

因为操作系统、CPU、编译程序等因素造成并发难题，有两方面的问题：运行环境和并发问题，前者影响后者。

##  运行环境

程序运行违背直觉，也是Bug源头

### 可见性

定义：一个线程对共享变量的修改，另外一个线程能够立刻看到

-   来源

CPU有多核，每核有自己的缓存，多个线程在不同CPU上执行，操作不同的缓存

-   目的

保证CPU缓存和内存数据一致性

-   方案

在Java里，使用Java内存模型解决，具体方法：提供给程序员按需禁用缓存的方法、针对可见性happens-before规则

### 原子性

定义：一个或者多个操作在CPU执行的过程中不被中断

-   来源

一条高级编程语言的语句需要多条CPU指令完成，操作系统会在某条CPU指令执行完切换其他线程运行

现代操作系统是基于线程调度，操作系统在做线程切换是，可以发生在任何一条CPU指令执行完

线程分时使用CPU即时间片，时间片结束时大多有线程切换

-   目的

保证高级语言里的语句可以被完整执行

-   方案

关键词：互斥，同一时刻只有一个线程执行，保证对共享变量的修改是互斥，临界区的代码是操作受保护资源的路径

实现：锁，一把锁保护多个资源是互斥的，一定有一个要锁定的对象

### 有序性

定义：程序按照代码的先后顺序执行

-   来源

编译器为了优化性能，有时会改变程序中语句的先后顺序，但不影响最终结果

-   目的

保证程序按照代码的先后顺序执行

-   方案

在Java里，使用Java内存模型解决，具体方法：提供给程序员按需禁用编译优化的方法

----

##  并发问题

并发编程有很多需要注意的地方，从以上就可以看出，还有其他问题，不过有大佬总结出来关键问题。

### 安全性问题

定义：保证程序按照期望的执行，不要出现意外

-   来源

不共享就不会相互伤害

存在共享数据并且该数据会发生变化，即多个线程会同时读写同一数据

-   具体表现

对于不共享数据或数据不变化，可以采用：线程本地存储、不变模式

对于必须共享会发生变化的数据：主要方式是互斥，即锁。

共享数据有两种场景：当多个线程同时访问同一数据，并且至少有一个线程会写这个数据时即数据竞争；线程的执行结果依赖线程执行的顺序即竞态条件。


### 活跃性问题

定义：某个操作无法执行下去

具体表现：死锁、活锁、饥饿

1.  死锁

定义：线程相互等待所需资源，并且会一直等待下去，即线程永久的阻塞

-   满足 4 个条件才会发生死锁
    -   互斥(共享资源X和Y只能被一个线程占用)
    -   占有且等待(线程T1已经取得共享资源X，在等待共享资源Y时，不释放共享资源X)
    -   不可抢占(其他线程不能强行抢占线程T1占有的资源)
    -   循环等待(线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源)
-   方法：破坏 4 个条件中的一个就可以，互斥是解决不了，本来就需要
    -   占有且等待：一次性申请所有的资源，就不等待
    -   不可抢占：占有部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放占有的资源
    -   循环等待：按序申请资源，即资源是有线性顺序的，先申请小再申请大，考虑"等待-通知"机制优化

2.  活锁

定义：有事线程虽然没有发生阻塞，但仍然会存在执行不下去的情况，如路上人面对面谦让

-   方法

谦让时尝试等待一个随机的时间

3.  饥饿

-   出现的场景
    -   在CPU繁忙的情况下，优先级低的线程执行机会很小
    -   持有锁的线程，执行的时间过长
-   方法
    -   公平得分配资源，使用公平锁
    -   避免持有锁的线程长时间执行


### 性能问题

定义：多线程不能发挥优势

-   来源

多线程因为过多使用"锁"导致串行化范围过大，性能较低

-   方法：尽量减少串行，就减少锁带来的性能问题
    -   锁带来的性能问题，使用无锁算法和数据结构
        -   线程本地存储
        -   写入时复制
        -   乐观锁
        -   原子类
    -   减少锁持有的时间
        -   细粒度的锁：如分段锁、读写锁

直到了问题所在，就是找到了靶子，再看该如何解决。

----
#   I/O 概述

速度在不断的提高，针对的场景越来越具体化。

##  基础知识

解决的问题：人机、机器之间交换数据

为了效率：BIO、NIO、AIO，时间就是生命

主要组成：传输数据的方式(文件/网络)、数据传输的格式(字节/字符)

存储单位：bit/比特/位(0101) * 8/n --> Byte/字节 * 1024 --> KB * 1024 --> MB * 1024 --> GB * 1024 -->  TB

bit 是计算机最小的单位，大部分使用 8位的块即字节 作为基本单位

API包：java.io、java.nio、java.net


##  API：JDK 的三次更新

每次更新的必要性，对前面的补充或优化

### JDK 1.0 到 1.3：IO

主要内容：字节流/字符流、File、套接字

为 Java 添加了 I/O 功能，是一种很朴实的方案，基于字节抽象出`流`的输入和输出，流代表数据传输的方向，本身并无状态。

因为字符比较常用，也提供了字符的输入输出流，字节与字符之间的转换涉及到编码。

File，代表文件，但不仅仅是文件，用于本地系统

套接字，网络编程的基础，是操作系统抽象出来提供给编程语言的接口，可以处理两个机器之间的通信。

这个版本的 I/O 模式是同步阻塞(BIO)模式，同步意味着当前线程仅做这么一件事情，阻塞就是发起请求后就睡眠等待数据到达被操作系统唤醒。

猜测一下：之所以是BIO，一是因为流已经处理了连接和数据，二是，数据已经到达JVM内存了

数据传输的格式是一个一个字节，虽然也有数组字节(缓冲区)，是一种优化，这种方式非常的基础底层，并且操作系统内存(内核空间)和常规进程(JVM/用户空间)之间至少存在一次拷贝

当时 Java 代码执行效率有待提高，优化 VM 层面就可以得到很高的性能。

### JDK 1.4：NIO

主要内容：缓冲器、通道、字符集、选择器

比较原来的基于流方式大大提高了速度，是现在高性能网络通信框架基本技术支撑。

缓冲器，固定数量的数据的容器，作用是存储器，代表了一块块数据，其实质是包在一个对象内的基本数据元数数组，将关于数据的数据内容和信息包含在一个单一的对象中，就像是中间站，位于来源和目的地之间。

通道，是一个创新的特性，不是原来流的补充，代表 缓冲器 和另一端实体之间的连接，发生在 文件系统和套接字 这两种数据传输方式上。

字符集，是解释字节表示的含义，同样的字节使用不同的字符解释有不同的结果，比如：UTF-8、GB2312。

选择器，用于实现多路复用。

这个版本的 I/O 模式是 同步非阻塞模式，具体套路是，多路复用(仅在套接字)，可以使用一个线程检查多个通道连接数据状态，而不需要每个连接对应一个线程。

猜测一下：之所以是NIO，一是因为把连接(通道)和数据(缓冲器)分开，二是，接收一个连接，数据来了写到指定地方，通过事件发布状态。通道就没有输入输出的说法，多了一个缓冲器

文件系统通道有个厉害的特性，内存映射文件，可以在 JVM 堆之外操作，实现零拷贝，效率大大提高，另外，还支持 文件锁，让我想到了 ACID 里面的 `隔离性`，可以一起读，但是只能一个线程改。

### JDK 7：NIO.2

主要内容：为 通道 添加异步特性，提供全新的文件系统接口

异步发生在 文件系统和套接字上，在多核高并发场景下再次提高速度。

文件系统接口是完全新抽象出来的，提供了以前难以实现的功能，比如：监视目录文件变化，另外对文件操作、描述做了专门的处理，简化了使用。

这个版本的 I/O 模式是 异步模式，就是线程发情请求之后，就去做其他的事情，至于数据准备和就绪之后的操作处理逻辑都是由操作系统处理，当然，也增加了复杂度，模式有点异于常人思维。

猜测一下：之所以是AIO，这个完全是系统内核支持，向系统发起请求的同时注册一个回调方法，当数据好了，系统主动调用这个回调方法，所以就需要一个线程，所以就需要一个特定的方法处理逻辑，就是给系统准备的。
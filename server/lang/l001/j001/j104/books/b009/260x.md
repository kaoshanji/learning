#   前言

Java 的劣势源于其最大的优势：一次编写，到处运行。Java 需要运行于虚拟机(JVM)之上，为了保证 Java 字节码在各种 JVM 部署平台上运行效果一致，有些妥协是必须的，既然需要通用于不同的操作系统平台，那么，某种程序上就必须选择各种平台都能接受的处理方案。

最切实感受到妥协带来的后果，莫过于 I/O 领域，虽然Java有一套完备的 I/O 类，但迄今为止还只是针对通用特性，通常位于高端抽象层，横跨各种操作系统，这些 I/O 类主要面向流数据，经常为了处理个别字节或字符，就要执行好几个对象层的方法调用。

这种面向对象的处理方法，将不同的 I/O 对象组合到一起，提供了高度的灵活性，但需要处理大量数据时，却可能对执行效率造成致命伤害。I/O 的终极目标是效率，而高效的 I/O 往往又无法与对象形成一一对应的关系。高效的 I/O 往往意味着要选择从 A 到 B 的最短路径，而执行大量 I/O 操作时，复杂性毁了执行效率。

传统 I/O 在移动大量数据时，可伸缩性不强，也没提供当今大多数操作系统普遍具备的常用 I/O 功能，如文件锁定、非块 I/O、就绪性选择和内存映射，这些特性对实现可伸缩性是至关重要的，对保持与非 Java 应用程序的正常交互也可以说是必不可少的。

当企业的需求是以最快的速度传送大量数据时，样貌朴实但迅捷的解决方案往往胜过漂亮却动作迟缓的，一句话，时间就是金钱。

##  缓冲区(Buffers)

 新的 Buffer 类是常规 Java 类和通道之间的纽带。原始数据元素组成的固定长度数组，封装在包含状态信息的对象中，存入缓冲区。

 缓冲区提供可一个汇合点：通道既可提取放在缓冲区中的数据(写)，也可向缓冲区存入数据供读取(读)，还有一种特殊类型的缓冲区，用于内存映射文件

 ##  通道(Channels)

 NIO 新引入的最重要的抽象是通道的概念。 Channel 对象模拟了通信连接，管道既可以是单向的(进或出)，也可以是双向的(进和出)，可以把通道想象成连接缓冲区和 I/O 服务的捷径。

为了能够向与文件或套接字关联的通道进行存取，适当的地方都增加了新方法。

多数通道可工作在非块模式下，这意味着更好的可伸缩性，尤其是与选择器一同使用的时候。

-   文件锁定和内存映射文件

在多个进程协同工作的情况下，要协调各个进程对共享数据的访问，文件锁定是必不可少的工具。

将文件映射到内存，这样看来，磁盘上的文件数据就像是在内存中一样。这利用了操作系统的虚拟内存功能，无需在内存中实际保留一份文件的拷贝，就可实现文件内容的动态高速缓存。

-   套接字(Sockets)

套接字通道类为使用网络套接字实现交互提供了新方法，套接字通道工作于非块模式，并可与选择器一同使用。因此，多个套接字可实现多路传输，管理效率也比 java.net 提供的传统套接字更高。

##  选择器(Selectors)

选择器可实现就绪性选择。Selector 类提供了确定一个或多个通道当前状态的机制。

使用选择器，借助单一线程，就可对数量庞大的活动 I/O 通道实施监控和维护。

##  字符集

java.nio.charsets 提供了新类用于处理字符与字节流之间的映射关系。

----
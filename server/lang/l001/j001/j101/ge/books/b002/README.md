#   Java编程思想 第4版

>   第15章 泛型

一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。

在面向对象编程语言中，多态算是一种泛化机制。

例如，你可以将方法的参数类型设为基类，那么该方法就可以接受从这个基类中导出的任何类作为参数。这样的方法更加通用一些，可应用的地方也多一些。在类的内部也是如此，凡是需要说明类型的地方，如果都使用基类，确实能够具备更好的灵活性。

但是，考虑到除了 final 类不能扩展，其他任何类都可以被扩展，所以这种灵活性大多时候也会有一些性能损耗。

如果方法的参数是一个接口，而不是一个类，这种限制就放松很多。因为任何实现了该接口的类都能满足该方法，这也包括暂时还不存在的类，客户端程序员可以通过实现一个接口来满足类或方法。因此，接口允许快捷的实现类继承，也是我们有机会创建一个新类来做到这一点。

可是有时候，即使使用了接口，对程序的约束也还是太强了。因为一旦指明了接口，他就要求你的代码必须使用特定的接口，而我们希望达到的目的是编写`更通用`的代码，要是代码能够应用于 "某种不具体的类型"，而不是一个具体的接口或类。

这就是 Java SE5 的重大变化之一：泛型的概念。

泛型实现了参数化类型的概念，使代码可以应用于多种类型。"泛型"这个术语的意思是："适用于许多许多的类型"。

泛型在编程语言中出现时，其最初的目的是希望类或方法能够具备最广泛的表达能力，这正是通过解耦类或方法与所使用的类型之间的约束。

当你创建参数化类型的一个实例时，编译器会为你负责转型操作，并且保证类型的正确性。


##  目录
-   [与C++比较](10x.md)
-   [简单泛型](11x.md)
-   [泛型接口](12x.md)
-   [泛型方法](13x.md)
-   [匿名内部类](14x.md)
-   [构建复杂模型](15x.md)
-   [擦除的神秘之处](16x.md)
-   [擦除的补偿](17x.md)
-   [边界](18x.md)
-   [通配符](19x.md)
-   [问题](20x.md)
-   [自限定的类型](21x.md)
-   [动态类型安全](22x.md)
-   [异常](23x.md)
-   [混型](24x.md)
-   [潜在类型机制](25x.md)
-   [对缺乏潜在类型机制的补偿](26x.md)
-   [将函数对象用作策略](27x.md)
-   [总结：转型真的如此之遭吗？](28x.md)

----
#   泛型基本概念

引入泛型的主要动机是让开发人员更安全地使用 Java 标准库中的集合类，尽早地发现一些代码中包含的潜在错误。

Java 的集合类框架在 JDK 1.2 中被添加到 Java 标准库中，其中包含了常用的 java.util.List、java.util.Map 和 java.util.Set等接口及其实现类。

在 J2SE 5.0 引入泛型之前，Java 中的集合类对象实际上是异构类型对象的集合，就是什么类型的数据都可以添加到一个集合里。

为了能够存放任何类型的对象，集合类中的元素的类型统一为 Object 类。在存放元素时，不论对象的实际类型如何，都可以将其保存到集合中。在读取元素时，需要对得到的对象进行强制类型转换，转换成对象的实际类型。使用强制类型转换的问题在于，运行时才可以发现类型不兼容的情况，由 java.lang.ClassCastException 异常表示。运行时才发现的错误的处理代价比编译时发现的错误处理代价要高得多，应该尽可能早地发现这些错误。

集合中通常包含的是同构类型的对象，就是相同类型的数据对象，但是Java语言并没有提供相应的机制来阻止向一个集合类的对象中添加不正确类型的对象，开发人员也不能在代码中表明集合类的对象中应该包含的对象类型。

为了实现类型安全的集合类，J2SE 5.0 引入了泛型的语言特性。泛型中包含的具体内容比较多，主要包括泛型类型和泛型方法的声明和实例化。

泛型类型与一般类型的区别在于，泛型类型有形式类型参数，可以在泛型类型被实例化时替换成实际的具体类型。

##  定义和使用泛型类

-   jdkx.type.ge.books.b006.ObjectHolder

泛型类的使用与一般的Java类并没有太大的区别，只是需要为其中声明的形式类型参数指定实际的类型。

-   jdkx.type.ge.books.b006.ObjectHolderDemoApp

在创建出泛型类的对象之后，该对象在使用时的类型是受限的，上述代码参数的类型只能是 String 类型。

当Java类的内部逻辑是相同时，使用泛型代码，只需要一个Java类就可以表示不同的类型对象。

ObjectHolder 类是泛型类的声明，ObjectHolderDemoApp 是泛型类的使用方式。

如果在一个类型中使用了形式类型参数，则称该类型为泛型类型。

泛型类型可以被实例化，在实例化之后，泛型类型声明中的形式类型参数被替换成实际的类型，实例化之后的泛型类型被称为参数化类型。

##  泛型类型范围

对于同一个泛型类型来说，可能的参数化类型的数量非常多。

根据使用的实际类型，参数化类型分为两类：一类是不带通配符的类型，另外一类是带通配符的类型。

-   带通配符类型、不带通配符类型

通配符 "?" 的作用是表示一组类型的集合，可以匹配特定范围内的类型。使用时可以指定其上界或下界，来限制通配符表示的具体类型的范围。

不包含上界或下界的通配符称为无界通配符，例如，ObjectHolder<T>表示其中包含的对象的具体类型是不确定的，可以是任何类型。

##  形式类型参数定义

在Java中，除了枚举类型、匿名内部类型和异常类型之外，其他类型都可以添加形式类型参数，成为泛型类型。

形式类型参数的名称可以是Java中任何合法的标识符，一般使用单个大写字母作为形式类型参数的名称，以区别于一般的标识符。

形式类型参数可以有多个，如 "MyClass<S,U,V>"中声明了3个形式类型参数，不同的形式类型参数在代码中表示不同的含义。以集合类框架为例， List 接口只包含一个形式类型参数，表示列表中包含的元素的类型；而 Map 接口则包含两个形式类型参数，分别表示映射表中条目的键和值得类型。

##  形式类型参数区别

形式类型参数类似于一般的类型，但是两个存在一些差别。

两者的共同之处在于都可以作为类型使用在某些场合，包括作为方法的参数和返回值类型、作为域和局部变量的类型声明、进行强制类型转换及作为泛型类型和泛型方法的实际类型参数。

##  形式类型参数局限

但是形式类型参数在某些情况下不能使用的，包括不能用来创建对象和数组、不能作为父类型、不能使用在 instanceof 表达式中、不能使用其类型字面量、不能出现在异常处理中，以及不能出现在静态上下文中。

这就意味着，如果 T 是形式类型参数，类似 "new T()" 、 "new T[]"、"class MyClass extends T" 、 "instanceof T" 、 "T.class" 、"catch (T)" 和 "static T" 等都是无法通过编译的错误用法

这些限制源于 Java 中泛型类型的实现机制，即`类型擦除`。

##  原生类型

为了兼容 J2SE 5.0 之前的遗留代码，泛型类型在使用时可以不指定实际类型。如果不指定实际类型而直接使用类型声明，所得到的类型被称为原始类型。

如果在代码中直接使用 ObjectHolder 进行声明，则使用的是泛型类 ObjectHolder 的原始类型。

原始类型的作用是与无法使用泛型的遗留代码进行交互，除此之外，原始类型不应该用其他地方，否则引入泛型就变得毫无意义。

使用原始类型是不安全的操作，编译器会给出相关的警告信息。

##  泛型方法

在构造方法或一般方法的声明中也可以使用形式类型参数，包含形式类型参数的方法被称为泛型方法。

泛型方法与泛型类型并没有直接的关系。

在一个非泛型类型中同样可以包含泛型方法。泛型类型中的泛型方法可以使用在类型中定义的形式类型参数，也可以使用自己的形式类型参数。

在调用泛型方法时，通常不需要显式指定所用的实际类型。编译器可以根据方法调用时的实际参数类型和上下文信息进行类型推断。


----
#   概念汇总

1.  Java 核心技术

致使Java SE 5.0 中增加泛型机制的主要原因是为了满足在 1999 年制定的最早的Java规范需求之一(JSR 14)，专家组花费了5年左右的时间用来定义规范和测试实现。

使用泛型机制编写的程序代码要比那些杂乱无章的使用Object变量，然后再进行强制类型转换的代码具有更好的安全性和可读性。

泛型对于集合类尤其有用，例如，ArrayList 就是一个无处不在的集合类。

泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。

例如，不需要为聚集 String 和 File 对象分别设计不同的类，使用 ArrayList 类就可以聚集任何类型的对象，这是一个泛型程序设计的实例。

##  类型参数的好处

参数类型的魅力在于：使得程序具有更好的可读性和安全性。

当集合使用泛型时，add 方法编译器知道添加的类型，get 方式编译器知道获取的类型，确保前后类型一致。

##  谁想成为泛型程序员

一个泛型程序员的任务就是预测出所用类的未来可能有的所有用途。

通配符类型非常抽象，但是能让库的构建者编写出尽可能灵活的方法。

----

2.  Java编程思想

一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。

在面向对象编程语言中，多态算是一种泛化机制。

例如，你可以将方法的参数类型设为基类，那么该方法就可以接受从这个基类中导出的任何类作为参数。这样的方法更加通用一些，可应用的地方也多一些。在类的内部也是如此，凡是需要说明类型的地方，如果都使用基类，确实能够具备更好的灵活性。

但是，考虑到除了 final 类不能扩展，其他任何类都可以被扩展，所以这种灵活性大多时候也会有一些性能损耗。

如果方法的参数是一个接口，而不是一个类，这种限制就放松很多。因为任何实现了该接口的类都能满足该方法，这也包括暂时还不存在的类，客户端程序员可以通过实现一个接口来满足类或方法。因此，接口允许快捷的实现类继承，也是我们有机会创建一个新类来做到这一点。

可是有时候，即使使用了接口，对程序的约束也还是太强了。因为一旦指明了接口，他就要求你的代码必须使用特定的接口，而我们希望达到的目的是编写`更通用`的代码，要是代码能够应用于 "某种不具体的类型"，而不是一个具体的接口或类。

这就是 Java SE5 的重大变化之一：泛型的概念。

泛型实现了参数化类型的概念，使代码可以应用于多种类型。"泛型"这个术语的意思是："适用于许多许多的类型"。

泛型在编程语言中出现时，其最初的目的是希望类或方法能够具备最广泛的表达能力，这正是通过解耦类或方法与所使用的类型之间的约束。

当你创建参数化类型的一个实例时，编译器会为你负责转型操作，并且保证类型的正确性。

泛型的出现，最引入注目的一个原因，就是为了创建容器类。

通常而言，只会使用容器来存储一种类型的对象，泛型的主要目的之一就是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性。

因此，与其使用 Object，更喜欢暂时不指定类型，而是稍后再决定具体使用什么类型。要达到这个目的，需要使用类型参数，用尖括号括住，放在类名后面，然后在使用这个类的时候，再用实际的类型替换此类型参数。

----

3.  Java技术手册

早期的集合库有相当大的不足--数据结构完成隐藏了存储其中的数据类型。

虽然在使用集合操作数据，但是不知道集合里面的数据类型是什么？尴尬。

希望在使用如List这样的集合时知道所含元素类型，当把不合法的类型添加进来时，javac 就能检测到，导致编译出错，而不用等到运行时才发现问题。

泛型可以解决这个问题，是通过让容器的负载类型在尖括号中指定，这样就能让编译器捕获大量不安全的代码，不需要到运行时。这正是静态类型系统的关键所在--使用编译时信息协助排除大量运行时问题。

```Java
interface Box<T> {
    void box(T t);
    T unbox();
}
```

上述代码表明，Box 接口是通用结构，可以保存任意类型的负载，这不是一个完整的接口，更像是一系列接口的通用描述，每个接口对应的类型都能用在 T 的位置上。

----

5.   Java 编程的逻辑

泛型将接口的概念进一步延伸，"泛型"的字面意思就是广泛的类型。类、接口和方法代码都可以应用于非常广泛的类型，代码与他们能操作的数据类型不再绑定在一起，同一套代码可以用于多种数据类型，这样，不仅可以复用代码，降低耦合，而且可以提高代码的可读性和安全性。

-   泛型类
-   泛型方法
-   泛型接口
-   容器类

##  基本原理

Java 有 Java 编译器和 Java 虚拟机，编译器将Java源代码转换为 .class 文件，虚拟机加载并允许 .class 文件。

对于泛型类，Java编译器会将泛型代码转换为普通的非泛型代码，将类型参数T擦除，替换为 Object，插入必要的强制类型转换。

Java 虚拟机实际执行的时候，他是不知道泛型这回事的，只知道普通的类及代码。

##  泛型的好处

泛型主要有两个好处：

-   更好的安全性
-   更好的可读性

语言和程序设计的一个重要目标是将 bug 尽量消灭在摇篮里，能消灭在写代码的时候，就不要等到代码写完程序运行的时候。

开发环境会提示类型错误，编译时Java编译器也会提示，这就是类型安全。

使用泛型，开发环境和编译器能确保不会用错类型，为程序多设置一道安全防护网，也可以省去烦琐的强制类型转换，再加上明确的类型信息，代码可读性也会更好。

##  类型参数的限定

关于类型参数，只能把他当做 Object，但Java支持限定这个参数的一个界限。

-   上界为某个具体类
-   上界为某个接口
-   上界为其他类型参数，T extends E

----

6.  深入理解Java 7：核心技术与最佳实践

在程序中通常只对固定类型的对象进行操作，有些代码可以对多种不同类型的对象进行操作。实际使用的类型在代码中只是以参数形式出现的占位符，在具体实例化时，用实际类型替代其中的占位符，这种方式被称为泛型编程。

泛型适用于对抽象类型进行处理，可以有效地减少代码重复，通过一份代码即可对不同类型的对象进行操作，典型的例子是处理集合相关的数据结构。对于这些数据结构可以进行一些抽象的操作，如排序和反转等，这些操作只与数据结构的特征相关，与其中包含的对象的类型无关。在实现这些操作时，对象的类型用占位符表示即可，并不影响操作的实现逻辑，使用者可以根据需要指定实际的类型。

Java 语言在 J2SE 5.0 引入了泛型特性。泛型的主要动机是为了实现类型安全的集合类。除此之外，泛型还可以用来创建处理抽象类型的新类型。

引入泛型的主要动机是让开发人员更安全地使用 Java 标准库中的集合类，尽早地发现一些代码中包含的潜在错误。

Java 的集合类框架在 JDK 1.2 中被添加到 Java 标准库中，其中包含了常用的 java.util.List、java.util.Map 和 java.util.Set等接口及其实现类。

在 J2SE 5.0 引入泛型之前，Java 中的集合类对象实际上是异构类型对象的集合，就是什么类型的数据都可以添加到一个集合里。

为了能够存放任何类型的对象，集合类中的元素的类型统一为 Object 类。在存放元素时，不论对象的实际类型如何，都可以将其保存到集合中。在读取元素时，需要对得到的对象进行强制类型转换，转换成对象的实际类型。使用强制类型转换的问题在于，运行时才可以发现类型不兼容的情况，由 java.lang.ClassCastException 异常表示。运行时才发现的错误的处理代价比编译时发现的错误处理代价要高得多，应该尽可能早地发现这些错误。

集合中通常包含的是同构类型的对象，就是相同类型的数据对象，但是Java语言并没有提供相应的机制来阻止向一个集合类的对象中添加不正确类型的对象，开发人员也不能在代码中表明集合类的对象中应该包含的对象类型。

为了实现类型安全的集合类，J2SE 5.0 引入了泛型的语言特性。泛型中包含的具体内容比较多，主要包括泛型类型和泛型方法的声明和实例化。

泛型类型与一般类型的区别在于，泛型类型有形式类型参数，可以在泛型类型被实例化时替换成实际的具体类型。

##  定义和使用泛型类

-   jdkx.type.ge.books.b006.ObjectHolder

泛型类的使用与一般的Java类并没有太大的区别，只是需要为其中声明的形式类型参数指定实际的类型。

-   jdkx.type.ge.books.b006.ObjectHolderDemoApp

在创建出泛型类的对象之后，该对象在使用时的类型是受限的，上述代码参数的类型只能是 String 类型。

当Java类的内部逻辑是相同时，使用泛型代码，只需要一个Java类就可以表示不同的类型对象。

ObjectHolder 类是泛型类的声明，ObjectHolderDemoApp 是泛型类的使用方式。

如果在一个类型中使用了形式类型参数，则称该类型为泛型类型。

泛型类型可以被实例化，在实例化之后，泛型类型声明中的形式类型参数被替换成实际的类型，实例化之后的泛型类型被称为参数化类型。

##  泛型类型范围

对于同一个泛型类型来说，可能的参数化类型的数量非常多。

根据使用的实际类型，参数化类型分为两类：一类是不带通配符的类型，另外一类是带通配符的类型。

-   带通配符类型、不带通配符类型

通配符 "?" 的作用是表示一组类型的集合，可以匹配特定范围内的类型。使用时可以指定其上界或下界，来限制通配符表示的具体类型的范围。

不包含上界或下界的通配符称为无界通配符，例如，ObjectHolder<T>表示其中包含的对象的具体类型是不确定的，可以是任何类型。

##  形式类型参数定义

在Java中，除了枚举类型、匿名内部类型和异常类型之外，其他类型都可以添加形式类型参数，成为泛型类型。

形式类型参数的名称可以是Java中任何合法的标识符，一般使用单个大写字母作为形式类型参数的名称，以区别于一般的标识符。

形式类型参数可以有多个，如 "MyClass<S,U,V>"中声明了3个形式类型参数，不同的形式类型参数在代码中表示不同的含义。以集合类框架为例， List 接口只包含一个形式类型参数，表示列表中包含的元素的类型；而 Map 接口则包含两个形式类型参数，分别表示映射表中条目的键和值得类型。

##  形式类型参数区别

形式类型参数类似于一般的类型，但是两个存在一些差别。

两者的共同之处在于都可以作为类型使用在某些场合，包括作为方法的参数和返回值类型、作为域和局部变量的类型声明、进行强制类型转换及作为泛型类型和泛型方法的实际类型参数。

##  形式类型参数局限

但是形式类型参数在某些情况下不能使用的，包括不能用来创建对象和数组、不能作为父类型、不能使用在 instanceof 表达式中、不能使用其类型字面量、不能出现在异常处理中，以及不能出现在静态上下文中。

这就意味着，如果 T 是形式类型参数，类似 "new T()" 、 "new T[]"、"class MyClass extends T" 、 "instanceof T" 、 "T.class" 、"catch (T)" 和 "static T" 等都是无法通过编译的错误用法

这些限制源于 Java 中泛型类型的实现机制，即`类型擦除`。

##  原生类型

为了兼容 J2SE 5.0 之前的遗留代码，泛型类型在使用时可以不指定实际类型。如果不指定实际类型而直接使用类型声明，所得到的类型被称为原始类型。

如果在代码中直接使用 ObjectHolder 进行声明，则使用的是泛型类 ObjectHolder 的原始类型。

原始类型的作用是与无法使用泛型的遗留代码进行交互，除此之外，原始类型不应该用其他地方，否则引入泛型就变得毫无意义。

使用原始类型是不安全的操作，编译器会给出相关的警告信息。

##  泛型方法

在构造方法或一般方法的声明中也可以使用形式类型参数，包含形式类型参数的方法被称为泛型方法。

泛型方法与泛型类型并没有直接的关系。

在一个非泛型类型中同样可以包含泛型方法。泛型类型中的泛型方法可以使用在类型中定义的形式类型参数，也可以使用自己的形式类型参数。

在调用泛型方法时，通常不需要显式指定所用的实际类型。编译器可以根据方法调用时的实际参数类型和上下文信息进行类型推断。


----

7.  Java 7 编程高级进阶

泛型指的就是参数化类型，把参数类型化，类型代表一种抽象和定义，指定范围之类的类型。

##  什么是泛型

从字面上看，泛型就是参数化类型。

使用泛型可以创建泛化的类、接口和方法，并通过指定任意类型作为参数来操作对应类型的数据。

集合类库中定义的类就是使用泛型的典型示例。

`java.util.LinkedList<E>` 类是集合框架中典型的类。注意类声明中有一对尖括号，并且括号中间有参数E。

把这里的参数E叫做类型参数，用于表示列表中存储的元素的类型。由于是泛型类，因此需要通过使用实际类型(如String或Integer)替换参数E来进行实例化。

开发人员可以通过在代码中指定想要的类型来进行实例化，例如，如果想要创建只存储 Integer 类型值得 LinkedList 对象，可以在代码中使用如下语句：

```Java
new List<Integer> list = new LinkedList<>(); // 右边的类型可以被推导出来
```

把形如 `List<Integer>` 或 `List<String>` 的声明称为参数化类型。

----

##  为什么需要使用泛型

在程序代码中使用泛型，可以帮助编译器对代码更好的进行类型检查。

Java 一直被认为是一门强类型语言，`类型安全`是Java语言的主要特征之一，借助泛型，这一特性得到了进一步深化。

----

##  泛型示例程序

-   jdkx.type.ge.books.b007.FamousQuotes

当不使用类型参数时，任何类型都可以添加进入，例如 buildList方法，但是在遍历取出时需要强制转换，并且不同类型还是会出现异常，导致不能正常打印

当使用类型参数时，只能添加指定类型数据进去，不然编译器会报错，例如buildCheckedList方法，在遍历时不需要强制转换，并且也能正常打印。


----

##  类型安全

泛型设计最初的动机是为了通知编译器对集合的内容进行类型检查，目前，还被用在了其他许多类中。

这些类在他们的参数中使用了类型参数，使用时需要在源程序中指定实际类型来完成实例化，编译器在预编译时将类型参数替换成真实类型。

Java 使用的是静态类型，也叫做强类型，编译器会检查赋值给变量的数据类型是否恰当，将子类类型赋值给变量时会强制进行隐式类型转换。

----



# 复制：弱一致性模型协议

现在我们已经看过可以在越来越现实的一组受支持的故障情况下实施单拷贝一致性的协议，让我们把注意力转移到一旦我们放弃单拷贝要求就会打开的选项世界一致性。

总的来说，很难想出一个单一维度来定义或表征允许副本分歧的协议。大多数此类协议都是高度可用的，并且关键问题在于最终用户是否找到对其目的有用的保证，抽象和API，尽管在发生节点和/或网络故障时副本可能会发散。

为什么没有弱一致的系统更受欢迎？

正如我在介绍中所说，我认为分布式编程的大部分内容都是关于处理分发的两个后果的含义：

- 信息以光速传播
- 独立的事情独立失败

信息传播速度的限制所带来的含义是节点以不同的，独特的方式体验世界。单个节点上的计算很容易，因为所有内容都以可预测的全局总顺序发生。分布式系统上的计算很困难，因为没有全局总订单。

在最长的时间内（例如数十年的研究），我们通过引入全球总订单来解决这个问题。我已经讨论了通过创建顺序（以容错方式）实现强一致性的许多方法，其中没有自然发生的总顺序。

当然，问题在于执行订单是昂贵的。特别是在大型互联网系统中，系统需要保持可用状态。强制一致性的系统不像分布式系统那样：它的行为类似于单个系统，这对分区期间的可用性不利。

此外，对于每个操作，通常必须联系大多数节点 - 通常不仅仅是一次，而是两次（正如您在2PC的讨论中看到的那样）。在需要在地理上分布以为全球用户群提供足够性能的系统中，这尤其痛苦。

因此，默认情况下表现得像单个系统可能并不理想。

也许我们想要的是一个系统，我们可以编写不使用昂贵协调的代码，然后返回“可用”值。我们将允许不同的副本彼此分离 - 不是为了保持事物的有效性而且是为了容忍分区 - 而是试图找到一种以某种方式处理分歧的方法，而不是单一的事实。

最终的一致性表达了这个想法：节点可以在一段时间内相互分离，但最终它们会在价值上达成一致。

在提供最终一致性的系统集中，有两种类型的系统设计：

*最终与概率保证保持一致*。这种类型的系统可以在稍后的某点检测到冲突的写入，但不保证结果等同于某些正确的顺序执行。换句话说，冲突的更新有时会导致用较旧的值覆盖较新的值，并且在正常操作期间（或在分区期间）可能会发生一些异常。

近年来，提供单拷贝一致性的最具影响力的系统设计是亚马逊的Dynamo，我将讨论这个系统，它提供了与概率保证最终一致的系统。

*最终的一致性和强有力的保证*。这种类型的系统保证结果收敛到相当于某些正确顺序执行的公共值。换句话说，这种系统不会产生任何异常结果; 在没有任何协调的情况下，您可以构建相同服务的副本，并且这些副本可以以任何模式进行通信并以任何顺序接收更新，并且只要它们都看到相同的信息，它们最终将同意最终结果。

CRDT（会聚复制数据类型）是数据类型，可以保证在网络延迟，分区和消息重新排序的情况下收敛到相同的值。它们可以证明是收敛的，但可以作为CRDT实现的数据类型是有限的。

CALM（作为逻辑单调性的一致性）猜想是相同原理的另一种表达：它将逻辑单调性与收敛等同起来。如果我们可以断定某些东西在逻辑上是单调的，那么在没有协调的情况下运行也是安全的。汇流分析 - 特别是应用于Bloom编程语言 - 可用于指导程序员决定何时何地使用来自强一致系统的协调技术，以及何时可以安全地执行而无需协调。

## 协调不同的操作订单

不强制执行单拷贝一致性的系统是什么样的？让我们试着通过一些例子来说明这一点。

也许不强制实现单拷贝一致性的系统最明显的特征是它们允许副本彼此分离。这意味着没有严格定义的通信模式：副本可以彼此分离，但仍然可用并接受写入。

让我们设想一个由三个副本组成的系统，每个副本都与其他副本分开。例如，副本可能位于不同的数据中心，并且由于某种原因无法进行通信。每个副本在分区期间仍然可用，接受来自某些客户端的读取和写入：

```bash
[Clients]   - > [A]

--- Partition ---

[Clients]   - > [B]

--- Partition ---

[Clients]   - > [C]
```

一段时间后，分区会恢复，副本服务器会交换信息。他们收到了来自不同客户的不同更新，并且相互分歧，因此需要进行某种协调。我们希望发生的是所有复制品都汇聚到相同的结果。

```bash
[A] \
    --> [merge]
[B] /     |
          |
[C] ----[merge]---> result
```

考虑具有弱一致性保证的系统的另一种方法是想象一组客户端以某种顺序向两个副本发送消息。由于没有强制执行单个总订单的协调协议，因此可以在两个副本的不同订单中传递消息：

```bash
[Clients]  --> [A]  1, 2, 3
[Clients]  --> [B]  2, 3, 1
```

实质上，这就是我们需要协调协议的原因。例如，假设我们正在尝试连接字符串，并且消息1,2和3中的操作是：

```bash
1: { operation: concat('Hello ') }
2: { operation: concat('World') }
3: { operation: concat('!') }
```

然后，没有协调，A将产生“Hello World！”，B将产生“World！Hello”。

```bash
A: concat(concat(concat('', 'Hello '), 'World'), '!') = 'Hello World!'
B: concat(concat(concat('', 'World'), '!'), 'Hello ') = 'World!Hello '
```

这当然是不正确的。同样，我们想要发生的是复制品收敛到相同的结果。

记住这两个例子，让我们首先看看亚马逊的Dynamo建立基线，然后讨论一些新的方法来构建具有弱一致性保证的系统，例如CRDT和CALM定理。

## 亚马逊的Dynamo

亚马逊的Dynamo系统设计（2007）可能是最知名的系统，提供弱一致性保证但高可用性。它是许多其他现实世界系统的基础，包括LinkedIn的Voldemort，Facebook的Cassandra和Basho的Riak。

Dynamo是一个最终一致，高度可用的键值存储。键值存储就像一个大型哈希表：客户端可以`set(key, value)`通过键设置值并使用键检索它们`get(key)`。Dynamo集群由N个对等节点组成; 每个节点都有一组密钥，负责存储。

Dynamo优先考虑可用性而不是一致性; 它不保证单拷贝的一致性。相反，当写入值时，副本可能会彼此分离; 当读取密钥时，存在读取协调阶段，该阶段尝试在将值返回给客户端之前协调副本之间的差异。

对于亚马逊上的许多功能而言，避免中断比确保数据完全一致更为重要，因为中断可能导致业务丢失和信誉丧失。此外，如果数据不是特别重要，那么弱一致的系统可以以比传统RDBMS更低的成本提供更好的性能和更高的可用性。

由于Dynamo是一个完整的系统设计，因此除核心复制任务外，还有许多不同的部分需要考虑。下图说明了一些任务; 值得注意的是，如何将写入路由到节点并写入多个副本。

```bash
[ Client ]
    |
( Mapping keys to nodes )
    |
    V
[ Node A ]
    |     \
( Synchronous replication task: minimum durability )
    |        \
[ Node B]  [ Node C ]
    A
    |
( Conflict detection; asynchronous replication task:
  ensuring that partitioned / recovered nodes recover )
    |
    V
[ Node D]
```

在查看最初如何接受写入之后，我们将查看如何检测冲突以及异步副本同步任务。由于高可用性设计，此任务是必需的，其中节点可能暂时不可用（向下或分区）。副本同步任务可确保节点即使在发生故障后也能够快速赶上。

### 一致的散列

无论我们是在阅读还是写作，首先需要确定的是我们需要确定数据在系统中应该存在的位置。这需要某种类型的键到节点映射。

在Dynamo中，使用称为[一致散列](https://github.com/mixu/vnodehash)的散列技术将密钥映射到节点（我将不再详细讨论）。主要思想是可以通过客户端上的简单计算将密钥映射到负责它的一组节点。这意味着客户端可以定位密钥而无需向系统查询每个密钥的位置; 这节省了系统资源，因为散列通常比执行远程过程调用更快。

### 部分法定人数

一旦我们知道应该存储密钥的位置，我们就需要做一些工作来保持价值。这是一个同步任务; 我们将立即将值写入多个节点的原因是为了提供更高级别的持久性（例如，防止节点的即时故障）。

就像Paxos或Raft一样，Dynamo使用仲裁进行复制。然而，Dynamo的法定人数是草率（部分）法定人数而不是严格（多数）法定人数。

非正式地，严格的仲裁系统是仲裁系统，其特性是仲裁系统中的任何两个仲裁（集）重叠。要求多数人在接受更新之前投票支持更新，可以保证只允许一个历史记录，因为每个多数仲裁必须在至少一个节点上重叠。例如，这就是Paxos所依赖的财产。

部分法定人数没有该财产; 这意味着不需要多数，并且仲裁的不同子集可能包含相同数据的不同版本。用户可以选择要写入和读取的节点数：

- 用户可以选择写入成功所需的一些W-of-N节点; 和
- 用户可以指定在读取期间要联系的节点数（R-of-N）。

`W`并`R`指定需要参与写入或读取的节点数。写入更多节点会使写入速度稍慢但会增加值不丢失的可能性; 从更多节点读取会增加读取值是最新的概率。

通常的建议是`R + W > N`，因为这意味着读取和写入仲裁在一个节点中重叠 - 使得返回陈旧值的可能性降低。典型配置是`N = 3`（例如，每个值总共三个副本）; 这意味着用户可以选择：

```bash
R = 1, W = 3;
 R = 2, W = 2 or
 R = 3, W = 1
```

更一般地，再次假设`R + W > N`：

- `R = 1`，`W = N`：快速读取，慢速写入
- `R = N`，`W = 1`：快速写入，慢速读取
- `R = N/2`并且`W = N/2 + 1`：对两者都有利

N很少超过3，因为保留大量数据的大量副本变得昂贵！

正如我之前提到的，Dynamo论文启发了许多其他类似的设计。它们都使用相同的基于部分仲裁的复制方法，但N，W和R的默认值不同：

- Basho的Riak（N = 3，R = 2，W = 2默认）
- Linkedin的伏地魔（N = 2或3，R = 1，W = 1默认值）
- Apache的Cassandra（N = 3，R = 1，W = 1默认值）

还有另一个细节：当发送读或写请求时，所有N个节点都被要求响应（Riak），或者只有满足最小值的节点（例如R或W; Voldemort）。“发送到所有”方法更快，对延迟更不敏感（因为它只等待N的最快R或W节点）但效率也较低，而“发送到最小”方法对延迟（因为与单个节点通信的延迟会延迟操作）但也更有效（整体消息/连接更少）。

当读写仲裁重叠时会发生什么，例如（`R + W > N`）？具体而言，经常声称这导致“强一致性”。

### R + W> N与“强一致性”相同吗？

没有。

它并非完全偏离基础：一个`R + W > N`可以检测读/写冲突的系统，因为任何读取仲裁和任何写入仲裁都会共享一个成员。例如，至少有一个节点在两个法定数量中：

```bash
 1     2   N/2+1     N/2+2    N
  [...] [R]  [R + W]   [W]    [...]
```

这保证了后续读取将看到先前的写入。但是，只有当N中的节点永远不会改变时，这才成立。因此，Dynamo不符合条件，因为在Dynamo中，如果节点失败，集群成员资格可能会发生变化。

Dynamo旨在始终可写。它有一种机制，通过在原始服务器关闭时向负责某些密钥的节点集添加一个不同的，不相关的服务器来处理节点故障。这意味着不再保证法定人数始终重叠。即使`R = W = N`不符合条件，因为当法定人数大小等于N时，这些法定人数中的节点可能会在失败期间发生变化。具体而言，在分区期间，如果无法访问足够数量的节点，Dynamo将从不相关但可访问的节点向仲裁添加新节点。

此外，Dynamo不会以强制执行强一致性模型的系统的方式处理分区：即，在分区的两端都允许写入，这意味着至少在一段时间内系统不会充当单个副本。因此称`R + W > N`“强烈一致”是误导性的; 保证仅仅是概率性的 - 这不是强一致性所指的。

### 冲突检测和读取修复

允许副本分歧的系统必须有办法最终协调两个不同的值。正如在部分仲裁方法中简要提到的，一种方法是在读取时检测冲突，然后应用一些冲突解决方法。但这是怎么做到的？

通常，这是通过通过用一些元数据补充来跟踪一条数据的因果历史来完成的。客户端在从系统读取数据时必须保留元数据信息，并且在写入数据库时必须返回元数据值。

我们已经遇到过这样做的方法：矢量时钟可以用来表示值的历史。实际上，这就是最初的Dynamo设计用于检测冲突的内容。

但是，使用矢量时钟并不是唯一的选择。如果你看一下许多实际的系统设计，你可以通过查看它们跟踪的元数据来推断它们的工作方式。

*没有元数据*。当系统不跟踪元数据并且仅返回值时（例如，通过客户端API），它对并发写入没有任何特殊的作用。一个常见的规则是最后一位作家获胜：换句话说，如果两位作家同时写作，则只保留最慢作者的价值。

*时间戳*。名义上，具有更高时间戳值的值获胜。但是，如果时间没有仔细同步，那么来自具有故障或快速时钟的系统的旧数据会覆盖较新的值会发生许多奇怪的事情。Facebook的Cassandra是Dynamo变体，它使用时间戳而不是矢量时钟。

*版本号*。版本号可以避免与使用时间戳相关的一些问题。请注意，可以在多个历史记录可以准确跟踪因果关系的最小机制是矢量时钟，而不是版本号。

*矢量时钟*。使用矢量时钟，可以检测到并发和过期更新。然后执行读取修复成为可能，但在某些情况下（并发更改），我们需要请求客户端选择一个值。这是因为如果更改是并发的，并且我们对数据没有更多了解（就像使用简单的键值存储一样），那么最好不要随意丢弃数据。

当读取一个值时，客户联系`R`的`N`节点，并要求他们为一个键的最新值。它接受所有响应，丢弃严格较旧的值（使用向量时钟值来检测此值）。如果只有一个唯一的向量时钟+值对，则返回该值。如果存在多个同时编辑的矢量时钟+值对（例如，不可比较），则返回所有这些值。

从上面可以明显看出，读取修复可以返回多个值。这意味着客户端/应用程序开发人员必须通过根据某些特定于用例的标准选择值来偶尔处理这些情况。

此外，实际矢量时钟系统的一个关键组成部分是时钟不能永久增长 - 因此需要有一个程序，以便以安全的方式偶尔垃圾收集时钟，以平衡容错和存储要求。

### 副本同步：八卦和Merkle树

鉴于Dynamo系统设计能够容忍节点故障和网络分区，它需要一种方法来处理分区后重新加入集群的节点，或者更换或部分恢复故障节点时。

副本同步用于在发生故障后使节点更新，并定期使副本彼此同步。

八卦是用于同步复制品的概率技术。通信模式（例如，哪个节点与哪个节点联系）不是预先确定的。相反，节点有一些`p`尝试彼此同步的可能性。每`t`秒，每个节点挑选具有进行通信的节点。这提供了超出同步任务的额外机制（例如，部分仲裁写入），这使得副本更新。

八卦是可扩展的，没有单点故障，但只能提供概率保证。

为了在复制同步期间有效地进行信息交换，Dynamo使用了一种称为Merkle树的技术，我将不会详细介绍。关键的想法是数据存储可以在多个不同的粒度级别进行散列：表示整个内容的哈希，键的一半，键的四分之一等等。

通过维护这种相当精细的散列，节点可以比天真的技术更有效地比较它们的数据存储内容。一旦节点识别出哪些密钥具有不同的值，它们就会交换必要的信息以使副本更新。

### Dynamo在实践中：概率有界陈旧（PBS）

这几乎涵盖了Dynamo系统设计：

- 一致的散列来确定关键位置
- 阅读和写作的部分法定人数
- 通过矢量时钟和冲突检测和读取修复
- 用于复制同步的八卦

我们如何描述这样一个系统的行为？Bailis等人最近的一篇论文。（2012）描述了一种称为[PBS](http://pbs.cs.berkeley.edu/)（概率有界陈旧性）的方法，其使用从现实世界系统收集的模拟和数据来表征这种系统的预期行为。

PBS通过使用关于反熵（八卦）速率，网络延迟和本地处理延迟的信息来估计不一致程度，以估计读取的预期一致性水平。它已经在Cassandra中实现，其中定时信息被捎带在其他消息上，并且基于蒙特卡罗模拟中的该信息的样本来计算估计。

基于该论文，在正常操作期间，最终一致的数据存储通常更快并且可以在几十或几百毫秒内读取一致状态。下表说明了给定的读出不同的从相一致的99.9％概率所需的时间量`R`和`W`实证定时数据设置从LinkedIn（SSD和15K RPM磁盘）和Yammer的：

![来自PBS的论文](images/pbs.png)

例如，在Yammer情况下，从`R=1`，`W=1`到`R=2`，`W=1`将不一致窗口从1352 ms减少到202 ms - 同时保持读取延迟低于（32.6 ms）最快的严格仲裁（`R=3`，`W=1`; 219.27 ms）。

有关更多详细信息，请查看[PBS网站](http://pbs.cs.berkeley.edu/) 和相关文章。

## 无序编程

让我们回顾一下我们想要解决的各种情况的例子。第一个场景包括分区后面的三个不同的服务器; 在分区修复后，我们希望服务器收敛到相同的值。亚马逊的迪纳摩通过阅读使这个可能`R`出来的`N`节点，然后执行读取和解。

在第二个示例中，我们考虑了一个更具体的操作：字符串连接。事实证明，没有已知的技术可以使字符串连接解析为相同的值而不对操作施加顺序（例如，没有昂贵的协调）。但是，有些操作可以按任何顺序安全地应用，其中简单的寄存器不能这样做。正如Pat Helland所写：

> ......以操作为中心的工作可以交换（使用正确的操作和正确的语义），其中简单的READ / WRITE语义不适合交换。

例如，考虑一个系统，它以两种不同的方式实现简单的会计系统`debit`和`credit`操作：

- 使用寄存器`read`和`write`操作，和
- 使用具有本机`debit`和`credit`操作的整数数据类型

后一种实现更多地了解数据类型的内部，因此尽管操作被重新排序，它仍可以保留操作的意图。借记或贷记可以按任何顺序应用，最终结果是相同的：

```bash
100 + credit(10) + credit(20) = 130 and
100 + credit(20) + credit(10) = 130
```

但是，不能以任何顺序写入固定值：如果重新排序写入，则其中一个写入将覆盖另一个：

```bash
100 + write(110) + write(130) = 130 but
100 + write(130) + write(110) = 110
```

假设我们正在寻找一组整数的最大值（例如MAX（）），而不是字符串连接。消息1,2和3是：

```bash
1: { operation: max(previous, 3) }
2: { operation: max(previous, 5) }
3: { operation: max(previous, 7) }
```

然后，在没有协调的情况下，A和B都会收敛到7，例如：

```bash
A: max(max(max(0, 3), 5), 7) = 7
B: max(max(max(0, 5), 7), 3) = 7
```

在这两种情况下，两个副本以不同的顺序查看更新，但我们能够以尽管顺序相同的结果合并结果。由于`max`我们使用的合并过程（），结果在两种情况下都收敛到相同的答案。

可能无法编写适用于所有数据类型的合并过程。在Dynamo中，值是二进制blob，因此可以做的最好的事情是公开它并要求应用程序处理每个冲突。

但是，如果我们知道数据是更具体的类型，则可以处理这些类型的冲突。CRDT是数据结构，旨在提供始终收敛的数据类型，只要它们看到相同的操作集（以任何顺序）。

## CRDT：收敛的复制数据类型

CRDT（会聚复制数据类型）利用有关特定数据类型的特定操作的可交换性和关联性的知识。

为了使一组操作在副本仅偶尔通信的环境中收敛于相同的值，操作需要与顺序无关并且对（消息）重复/重新传递不敏感。因此，他们的操作需要是：

- 关联（`a+(b+c)=(a+b)+c`），因此分组无关紧要
- 交换（`a+b=b+a`），所以应用顺序无关紧要
- 幂等（`a+a=a`），因此重复无关紧要

事实证明，这些结构在数学中已为人所知; 它们被称为连接或满足[半格](http://en.wikipedia.org/wiki/Semilattice)。

甲[晶格](http://en.wikipedia.org/wiki/Lattice_(order))是部分有序集与不同的顶部（最小上界）和不同的底（最大下界）。半格子就像一个格子，但只有一个独特的顶部或底部。连接半格是具有不同顶部（最小上边界）的半格，并且满足半格是具有不同底部（最大下边界）的半格。

任何表示为半格的数据类型都可以实现为保证收敛的数据结构。例如，计算`max()`一组值的总是会返回相同的结果，无论接收到的值的顺序如何，只要最终接收到所有值，因为该`max()`操作是关联的，可交换的和幂等的。

例如，这里有两个格子：一个为集合绘制，其中合并运算符是`union(items)`一个，而一个是为严格增加的整数计数器绘制的，其中合并运算符是`max(values)`：

```bash
   { a, b, c }              7
  /      |    \            /  \
{a, b} {b,c} {a,c}        5    7
  |  \  /  | /           /   |  \
  {a} {b} {c}            3   5   7
```

对于可以表示为半格的数据类型，您可以让副本以任何模式进行通信，并以任何顺序接收更新，只要它们都看到相同的信息，它们最终会同意最终结果。这是一个强大的属性，只要先决条件成立，就可以保证。

但是，将数据类型表示为半格点通常需要一定程度的解释。许多数据类型的操作实际上不依赖于顺序。例如，向集合添加项目是关联的，可交换的和幂等的。但是，如果我们还允许从集合中删除项目，那么我们需要一些方法来解决冲突操作，例如`add(A)`和`remove(A)`。如果本地副本从未添加元素，删除元素意味着什么？必须以与顺序无关的方式指定该分辨率，并且存在具有不同权衡的若干不同选择。

这意味着几种熟悉的数据类型具有更专业的实现作为CRDT，它们进行不同的权衡以便以与顺序无关的方式解决冲突。与仅处理寄存器的键值存储（例如，从系统的角度来看是不透明的blob的值）不同，使用CRDT的人必须使用正确的数据类型来避免异常。

指定为CRDT的不同数据类型的一些示例包括：

- 计数器
  - 仅增长计数器（merge = max（values）; payload = single integer）
  - 正负计数器（由两个增长计数器组成，一个用于增量，另一个用于减量）
- 寄存器
  - Last Write Wins -register（时间戳或版本号; merge = max（ts）; payload = blob）
  - 多值寄存器（矢量时钟;合并=两者兼有）
- 集
  - 仅限成长集（merge = union（items）; payload = set; no removal）
  - 两相组（由两组组成，一组用于添加，另一组用于移除;元素可以添加一次并删除一次）
  - 独特套装（两相套装的优化版本）
  - 上次写入获胜设置（merge = max（ts）; payload = set）
  - 正负集（每个项目包含一个PN计数器）
  - 观察删除集
- 图形和文本序列（见文章）

为了确保无异常操作，您需要为特定应用程序找到正确的数据类型 - 例如，如果您知道只删除一次项目，那么两阶段设置有效; 如果您只将项目添加到集合中并且永远不会删除它们，那么只有增长集合才有效。

并非所有数据结构都已知为CRDT，但[Shapiro等人](http://hal.inria.fr/docs/00/55/55/88/PDF/techreport.pdf)最近（2011年）的[调查报告](http://hal.inria.fr/docs/00/55/55/88/PDF/techreport.pdf)中提到了布尔，计数器，集合，寄存器和图形的CRDT实现。

有趣的是，寄存器实现直接对应于键值存储使用的实现：last-write-wins寄存器使用时间戳或某些等价物，并简单地收敛到最大的时间戳值; 多值寄存器对应于保留，公开和协调并发更改的Dynamo策略。有关详细信息，建议您查看本章后续部分中的论文。

## CALM定理

CRDT数据结构基于这样的认识：可以表示为半格的数据结构是收敛的。但是编程不仅仅是发展状态，除非您只是实现数据存储。

显然，顺序独立性是任何收敛计算的重要特性：如果接收数据项的顺序影响计算结果，则无法在不保证顺序的情况下执行计算。

但是，有许多编程模型，其中语句的顺序不起重要作用。例如，在[MapReduce模型中](http://en.wikipedia.org/wiki/MapReduce)，Map和Reduce任务都被指定为需要在数据集上运行的无状态元组处理任务。没有明确指定有关如何以及以何种顺序将数据路由到任务的具体决策，而是批处理作业调度程序负责调度要在群集上运行的任务。

类似地，在SQL中，一个指定查询，但不指定查询的执行方式。查询只是对任务的声明性描述，查询优化器的工作是找出执行查询的有效方法（跨多个机器，数据库和表）。

当然，这些编程模型不像通用编程语言那样容许。MapReduce任务需要在非循环数据流程序中表达为无状态任务; SQL语句可以执行相当复杂的计算，但很多事情很难在其中表达。

但是，从这两个例子中可以清楚地看出，有许多类型的数据处理任务可以用声明性语言表达，其中没有明确指定执行顺序。编程模型表达期望的结果，同时将语句的确切顺序留给优化器来决定，通常具有与顺序无关的语义。这意味着这些程序可以在没有协调的情况下执行，因为它们取决于它们接收的输入，但不一定取决于接收输入的特定顺序。

关键是这些程序*可以*安全地执行而无需协调。如果没有一个明确的规则来表征没有协调就可以安全执行的事情，那么我们就无法实现一个程序，同时确保结果是正确的。

这就是CALM定理的意义所在。CALM定理基于对逻辑单调性与最终一致性的有用形式（例如汇合/收敛）之间的联系的识别。它声明逻辑上单调的程序最终保持一致。

然后，如果我们知道某些计算在逻辑上是单调的，那么我们就知道在没有协调的情况下执行它也是安全的。

为了更好地理解这一点，我们需要将单调逻辑（或单调计算）与[非](http://plato.stanford.edu/entries/logic-nonmonotonic/)单调逻辑（或非单调计算）进行对比。

- 单调

  如果判刑`φ`是一组处所的后果`Γ`，那么也可以从任何一组`Δ`处所延伸出来`Γ`

大多数标准逻辑框架都是单调的：在一个框架内进行的任何推断，例如一阶逻辑，一旦演绎有效，就不能被新信息无效。非单调逻辑是一种系统，其中该属性不成立 - 换句话说，如果通过学习新知识可以使某些结论无效。

在人工智能社区中，非单调逻辑与[可推理的](http://plato.stanford.edu/entries/reasoning-defeasible/)推理相关联- 推理，其中利用部分信息的断言可以被新知识无效。例如，如果我们得知特威蒂是一只鸟，我们会认为特威蒂可以飞; 但如果我们后来得知特威蒂是一只企鹅，那么我们就必须修改我们的结论。

单调性涉及前提（或关于世界的事实）和结论（或关于世界的断言）之间的关系。在单调逻辑中，我们知道我们的结果是无回缩的：[单调](http://en.wikipedia.org/wiki/Monotonicity_of_entailment)计算不需要重新计算或协调; 随着时间的推移，答案会更准确。一旦我们知道特威蒂是一只鸟（并且我们推理使用单调逻辑），我们就可以得出结论，特威蒂可以飞行，我们学到的任何东西都无法得出这个结论。

虽然产生面向人类结果的任何计算都可以被解释为关于世界的断言（例如“foo”的值是“bar”），但很难确定基于冯诺依曼机器的编程模型中的计算是否是单调的，因为事实和断言之间的关系以及这些关系是否是单调的并不清楚。

然而，有许多编程模型可以确定单调性。特别是，[关系代数](http://en.wikipedia.org/wiki/Relational_algebra)（例如SQL的理论基础）和[Datalog](http://en.wikipedia.org/wiki/Datalog)提供了具有良好理解解释的高度表达语言。

基本的Datalog和关系代数（即使是递归）都是单调的。更具体地说，已知使用一组基本运算符表示的计算是单调的（选择，投影，自然连接，叉积，联合和递归Datalog而没有否定），并且通过使用更高级的运算符引入非单调性（否定，设定差异，划分，普遍量化，聚合）。

这意味着在这些系统中使用大量运算符（例如map，filter，join，union，intersection）表示的计算在逻辑上是单调的; 使用这些运算符的任何计算也是单调的，因此在没有协调的情况下运行是安全的。另一方面，利用否定和聚合的表达式在没有协调的情况下运行是不安全的。

重要的是要实现非单调性与在分布式系统中执行昂贵的操作之间的联系。具体而言，*分布式聚合*和*协调协议*都可以被认为是一种否定形式。正如Joe Hellerstein [所写](http://www.eecs.berkeley.edu/Pubs/TechRpts/2010/EECS-2010-90.pdf)：

> 为了在分布式设置中建立否定谓词的准确性，评估策略必须开始“计数到0”以确定空虚，并等待分布式计数过程明确终止。聚合是这个想法的概括。

和：

> 这个想法也可以从另一个方向看出来。协调协议本身就是聚合，因为它们需要投票：两阶段提交需要一致投票，Paxos共识需要多数票，而拜占庭协议需要2/3多数票。等待需要计算。

如果，然后我们可以以可以测试单调性的方式表达我们的计算，那么我们可以执行整个程序静态分析，该程序检测程序的哪些部分最终是一致的并且在没有协调的情况下安全运行（单调的零件） - 哪些零件不是（非单调零件）。

请注意，这需要不同类型的语言，因为对于传统编程语言来说，这些推论很难做到，其中序列，选择和迭代是核心。这就是Bloom语言设计的原因。

## 什么是非单一性有益？

单调性和非单调性之间的区别很有趣。例如，添加两个数字是单调的，但计算包含数字的两个节点上的聚合则不是。有什么不同？其中一个是计算（添加两个数字），而另一个是断言（计算聚合）。

计算如何与断言不同？让我们考虑一下这个问题“比萨饼是蔬菜吗？”。要回答这个问题，我们需要找到核心：什么时候可以推断出某些东西是（或不是）是真的？

有几个可接受的答案，每个答案都对应于我们所拥有的信息和我们应该对其采取行动的不同假设 - 我们已经接受了不同背景下的不同答案。

在日常推理中，我们做出了所谓的[开放世界假设](http://en.wikipedia.org/wiki/Open_world_assumption)：我们假设我们不知道一切，因此无法从缺乏知识得出结论。也就是说，任何句子都可能是真的，错误的或未知的。

```bash
                                OWA +             |  OWA +
                                Monotonic logic   |  Non-monotonic logic
Can derive P(true)      |   Can assert P(true)    |  Cannot assert P(true)
Can derive P(false)     |   Can assert P(false)   |  Cannot assert P(true)
Cannot derive P(true)   |   Unknown               |  Unknown
or P(false)
```

在做出开放世界的假设时，我们只能安全地断言我们可以从已知的东西中推断出来的东西。我们假设我们的世界信息不完整。

让我们首先看一下我们知道我们的推理是单调的情况。在这种情况下，我们所拥有的任何（可能不完整的）知识都不能通过学习新知识而失效。因此，如果我们可以根据一些推论推断一个句子是真的，例如“含有两汤匙番茄酱的东西是蔬菜”和“披萨含有两汤匙番茄酱”，那么我们可以得出结论“披萨是一种蔬菜”。如果我们可以推断一个句子是假的，那也是一样的。

但是，如果我们不能推断出任何东西 - 例如，我们所拥有的知识集包含客户信息而不包含披萨或蔬菜 - 那么在开放世界的假设下我们不得不说我们无法做出任何结论。

对于非单调知识，我们现在所知道的任何事情都可能被无效。因此，即使我们可以从我们目前所知道的内容中推断出真或假，我们也无法安全地得出任何结论。

但是，在数据库环境中，在许多计算机科学应用程序中，我们更愿意做出更明确的结论。这意味着假设所谓的[封闭世界假设](http://en.wikipedia.org/wiki/Closed_world_assumption)：任何无法显示为真的东西都是假的。这意味着不需要明确宣布虚假陈述。换句话说，假设我们拥有的事实数据库是完整的（最小的），因此可以假定其中没有的任何事物都是假的。

例如，根据CWA，如果我们的数据库没有旧金山和赫尔辛基之间航班的条目，那么我们可以得出结论，没有这样的航班存在。

我们还需要一件事能够做出明确的断言：[逻辑上的限制](http://en.wikipedia.org/wiki/Circumscription_(logic))。Circumscription是一种形式化的猜想规则。域限制猜想已知实体都存在。我们需要能够假设所有已知实体都是为了得出明确的结论。

```bash
 CWA +             |  CWA +
                                Circumscription + |  Circumscription +
                                Monotonic logic   |  Non-monotonic logic
Can derive P(true)      |   Can assert P(true)    |  Can assert P(true)
Can derive P(false)     |   Can assert P(false)   |  Can assert P(false)
Cannot derive P(true)   |   Can assert P(false)   |  Can assert P(false)
or P(false)
```

特别是，非单调推论需要这种假设。如果我们假设我们有完整的信息，我们只能做出自信的断言，因为额外的信息可能会使我们的断言无效。

这在实践中意味着什么？首先，单调逻辑可以在得出句子为真（或错误）时立即得出明确的结论。其次，非单调逻辑需要一个额外的假设：已知的实体都存在。

那么为什么表面上的两个操作等效不同呢？为什么添加两个数字是单调的，但计算两个节点上的聚合不是？因为聚合不仅计算总和，而且断言它已经看到了所有的值。保证这一点的唯一方法是跨节点进行协调，并确保执行计算的节点确实已经看到了系统中的所有值。

因此，为了处理非单调性，需要使用分布式协调来确保仅在所有信息已知之后才进行断言，或者在断言时断言以后可以使结论无效。

出于表达的原因，处理非单调性很重要。这归结为能够表达非单调的东西; 例如，能够说某些列的总数是X是很好的。系统必须检测到这种计算需要全局协调边界以确保我们已经看到了所有实体。

纯粹的单调系统很少见。似乎大多数应用程序在封闭世界的假设下运行，即使它们的数据不完整，我们人类对此也很好。当数据库告诉您旧金山和赫尔辛基之间的直飞航班不存在时，您可能会将此视为“根据此数据库，没有直接航班”，但您不排除实际存在的可能性航班可能仍然存在。

实际上，当副本可能发散时（例如在分区期间或由于正常操作期间的延迟），此问题才变得有趣。然后需要更具体的考虑：答案是仅基于当前节点还是基于系统的整体。

此外，由于非单调性是通过做出断言引起的，似乎有理由认为许多计算可以进行很长时间并且仅在将某些结果或断言传递给第三方系统或最终用户的点处应用协调。当然，如果那些读取和写入仅仅是长时间运行计算的一部分，则系统内的每个读取和写入操作都不必强制执行总命令。

## 布卢姆语

该[布鲁姆语言](http://www.bloom-lang.net/)是一个旨在利用CALM定理的语言。它是一个Ruby DSL，它在称为Dedalus的时态逻辑编程语言中具有正式基础。

在Bloom中，每个节点都有一个由集合和格子组成的数据库。程序表示为与集合（事实集合）和格子（CRDT）交互的无序语句集。默认情况下，语句与顺序无关，但也可以编写非单调函数。

查看[Bloom网站](http://www.bloom-lang.net/)和[教程](https://github.com/bloom-lang/bud/tree/master/docs)，了解有关Bloom的更多信息。

------

## 进一步阅读

#### CALM定理，汇流分析和Bloom

[Joe Hellerstein的演讲@RICON 2012](http://vimeo.com/53904989)是对该主题的一个很好的介绍，就像[Neil Conway的演讲@Basho一样](http://vimeo.com/45111940)。特别是Bloom，请参阅[Peter Alvaro的演讲@Microsoft](http://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2012/Bloom-Disorderly-Programming-for-a-Distributed-World)。

- [声明的命令：分布式逻辑中的经验和猜想](http://www.eecs.berkeley.edu/Pubs/TechRpts/2010/EECS-2010-90.pdf) - Hellerstein，2010
- [Bloom中的一致性分析：CALM和收集方法](http://db.cs.berkeley.edu/papers/cidr11-bloom.pdf) - Alvaro等，2011
- [分布式编程的逻辑和格式](http://db.cs.berkeley.edu/papers/UCB-lattice-tr.pdf) - Conway等，2012
- [Dedalus：时空数据目录](http://db.cs.berkeley.edu/papers/datalog2011-dedalus.pdf) - Alvaro等，2011

#### CRDTs

[Marc Shapiro的演讲@微软](http://research.microsoft.com/apps/video/dl.aspx?id=153540)是了解CRDT的一个很好的起点。

- [CRDT：没有并发控制的一致性](http://hal.archives-ouvertes.fr/docs/00/39/79/81/PDF/RR-6956.pdf) - Letitia等，2009
- [综合研究Convergent和交换复制数据类型](http://hal.inria.fr/docs/00/55/55/88/PDF/techreport.pdf)，Shapiro等，2011
- [优化的无冲突复制集](http://arxiv.org/pdf/1210.3368v1.pdf) - Bieniusa等，2012

#### 发电机; PBS; 乐观的复制

- [Dynamo：亚马逊的高可用键值商店](http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf) - DeCandia等，2007
- [PNUTS：雅虎的托管数据服务平台](http://scholar.google.com/scholar?q=PNUTS:+Yahoo!'s+Hosted+Data+Serving+Platform) - Cooper等，2008
- [Bayou架构：支持移动用户之间的数据共享](http://scholar.google.com/scholar?q=The+Bayou+Architecture%3A+Support+for+Data+Sharing+among+Mobile+Users) - Demers等。1994年
- [实用部分法定人数的概率约束陈旧](http://pbs.cs.berkeley.edu/pbs-vldb2012.pdf) --Bailis等，2012
- [今天的最终一致性：限制，扩展和超越](https://queue.acm.org/detail.cfm?id=2462076) - Bailis＆Ghodsi，2013
- [乐观复制](http://www.ysaito.com/survey.pdf) - Saito和Shapiro，2005年
# 饥饿和活锁

与死锁相比，饥饿和活锁不是常见的问题，但仍然存在并发软件的每个设计者都可能遇到的问题。

## 饥饿

*Starvation*描述了一种情况，即线程无法获得对共享资源的定期访问，并且无法取得进展。当“贪婪”线程使共享资源长时间不可用时，就会发生这种情况。例如，假设一个对象提供了一个通常需要很长时间才能返回的同步方法。如果一个线程经常调用此方法，则通常还需要阻止对同一对象进行频繁同步访问的其他线程。

## 活锁

线程通常用于响应另一个线程的操作。如果另一个线程的操作也是对另一个线程的操作的响应，则可能导致*活锁*。与死锁一样，活锁线程无法取得进一步进展。但是，线程没有被阻塞 - 他们只是太忙于相互回应以恢复工作。这相当于两个试图在走廊里互相通过的人：Alphonse向左移动让Gaston通过，而Gaston向右移动让Alphonse通过。看到他们仍然互相阻挡，Alphone向右移动，而Gaston向左移动。他们还在互相阻挡，所以......